classdef topsTreeNodeTopNode < topsTreeNode
   % Class topsTreeNodeTopNode
   %
   %  Special sub-class of topsTreeNode intended to be at the top level of
   % a tree-like structure that runs all of its children as an experiment.
   %
   %  Unlike other topsTreeNodes because it has guis and other helper
   % objects associated with it
   %
   % Created 7/24/18 by jig
   
   properties (SetObservable)
      
      % Abort experiment
      abortFlag=false;
      
      % Pause experiment
      pauseFlag=false;
      
      % Skip to next task
      skipFlag=false;
      
      % Recalibrate
      calibrateObject=[];
      
      % run GUI name or fevalable
      runGUIName = [];
      
      % args to the runGUI constructor
      runGUIArgs = {};
      
      % databaseGUI name
      databaseGUIName = [];
   end
   
   properties (Hidden)
      
      % handle to taskGui interface
      runGUIHandle = [];
      
      % databaseGUI name
      databaseGUIHandle = [];
      
      % silly flag to avoid errors with GUI startup
      isStarted = false;
   end
   
   methods
      % Constuct with optional argument:
      %  name              ... string name of the top node
      %  databaseGUIName   ... string name of the gui for database info
      %  runGUIName        ... string name of the run gui
      function self = topsTreeNodeTopNode(name, databaseGUIName, runGUIName)
         
         % Check arguments
         if nargin < 1 || isempty(name)
            name = 'topNode';
         end
         
         % ---- Create topsCallLists for start/finish fevalables
         %
         % These can be filled in by various configuration
         %  subroutines so we don't need to know where what has and has not been
         %  added/configured.
         startCallList = topsCallList();
         startCallList.alwaysRunning = false;
         
         % NOTE that the finishFevalables will run in reverse order!!!!!
         finishCallList = topsCallList();
         finishCallList.alwaysRunning = false;
         finishCallList.invertOrder = true;
         
         % ---- Set up the main tree node
         %
         % We set this up here because we might have multiple task configuration
         % files (see below) that each add chidren to it
         node = topsTreeNode(name);
         node.iterations = 1; % Go once through the set of tasks
         node.startFevalable = {@run, startCallList};
         node.finishFevalable = {@run, finishCallList};
         
         % ---- Possibly add the databaseGUI
         if nargin >= 2 && ~isempty(databaseGUIName)
            node.databaseGUIName = databaseGUIName;
         end
         
         % ---- Possibly add the runGUI
         if nargin >= 3 && ~isempty(runGUIName)
            node.runGUIName = runGUIName;
         end
      end
      
      % Overloaded start function, to check for gui(s)
      function start(self)
         
         % check for databaseGUI
         if ~isempty(self.databaseGUIName) && isempty(self.databaseGUIHandle)
            self.databaseGUIHandle = feval(self.databaseGUIName);
         end
         
         % check for runGUI
         if ~isempty(self.runGUIName) && isempty(self.runGUIHandle)
            self.runGUIHandle = feval(self.runGUIName, self, self.runGUIArgs{:});
         else
            self.start@topsRunnable();
            self.isStarted = true;
         end
      end
      
      % Overloaded finish function, needed because we might have started
      %  GUI but did not run anything
      function finish(self)
         
         if self.isStarted
            self.finish@topsRunnable();
         end
      end
      
      function updateGUI(self, name, varargin)
         
         if ~isempty(self.runGUIHandle)
            
            feval(self.runGUIName, [self.runGUIName name], ...
               self.runGUIHandle, [], guidata(self.runGUIHandle), varargin{:});
         end
      end
      
      % Check status flags. Return ~0 if something happened
      function ret = checkFlags(self, child)
         
         % Default return value
         ret = 0;
         
         % Possibly check gui
         if ~isempty(self.runGUIHandle)
            drawnow;
         end
         
         % Pause experiment, wait for ui
         while self.pauseFlag && ~self.abortFlag
            pause(0.01);
         end
         
         % Abort experiment
         if self.abortFlag
            self.abortFlag=false;
            self.abort();
            ret = 1;
            return
         end
         
         % Recalibrate
         if ~isempty(self.calibrateObject)
            calibrate(self.calibrateObject);
            self.calibrateObject = [];
         end
         
         % Skip to next task
         if self.skipFlag
            self.skipFlag=false;
            child.abort();
            ret = 1;
            return
         end
      end
      
      % add call to start/finish call list
      function addCall(type, fevalable, name)
            addCall(datatub{'Control'}{'startCallList'}, {@calibrate, ui}, 'calibrate eye');

      end
   end
end