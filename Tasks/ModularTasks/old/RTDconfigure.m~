function RTDconfigure(maintask, datatub, varargin)
% function RTDconfigure(maintask, datatub, varargin)
%
% RTD = Response-Time Dots
%
% Configure the RTD experiment, which consists of a combination of
%  multiple different tasks:
%  1. Quest       - Adaptive procedure to determine psychophysical
%                    threshold for coherence
%  2. MeanRT      - Determine mean RT for speed-accuracy trade-off
%                    (SAT) feedback
%  3. test        - RT dots with SAT and bias manipulations. see
%                    blockSpects below for details
%  4. VGS/MGS     - Visually and memory-guided saccade tassk
%
% Inputs:
%   datatub       -  A topsGroupedList object containing experimental
%                    parameters as well as data recorded during the
%                    experiment.
%   maintask      - the topsTreeNode object to run
%
%  plus varargin, which are property/value pairs:
%
%  'coherences'      - coherences to use in non-Quest blocks. If Quest
%                       is used, this is overridedn
%  'dotDirections'   - dot directions
%  'biasedPriors'    - priors to use in BIAS blocks
%  'referenceRT'     - scalar value (in sec) to use as reference for feeback
%                       on 'speed' trials. If none given, computed from
%                       Quest or meanRT block
%  'taskSpecs'       - cell array that defines the tasks. Each pair is:
%                       1 : Task name, which can be 'Quest', 'meanRT', or
%                         a pair of keys:
%                           <SAT instruction key>:
%                             'S'=Speed, 'A'=Accuracy, 'N'=Neutral
%                           <BIAS stimulus key>:
%                             'L'=More left, 'R'=More right, 'N'=Neutral
%                       2 : <number of trials>
%  'uiDevice',        - string name of dotsReadable* class to use for
%                       choice input
%  'fixWindowSize',   - diameter of fixation gaze window, in degrees vis angle
%  'targetWindowSize', - diameter of target gaze window, in degrees vis angle
%  'fixWindowDur',    - duration for fix window (gaze holding time), in sec
%  'trgWindowDur',    - duration for target window (gaze holding time), in sec
%  'sendTTLs'         - flag, set to true to send TTL pulses via the PMD
%  'useRemoteDrawing' - true or false. If true, use RTDconfigureIPs to set
%                          communication parameters
%  'displayIndex'      - see dotsTheScreen (0:small window; 1=main window;
%                          2:secondary window)
%  'filePath'          - <string> where to put the data files
%  'fileName'          - <string> name. Note that when pupil labs is used,
%                          a second file is created with name
%                          <filename>_pupil
%
% 5/11/18   updated by jig
% 10/2/17   xd wrote it

%% ---- Parse arguments
c = clock;
defaultArguments = { ...
   'taskSpecs',            {'Quest', 40, 'SN' 20 'AN' 20}; ...
   'coherences',           [0 3.2 6.4 12.8 25.6 51.2]; ...
   'dotDirections',        [0 180]; ...
   'biasedPriors',         [20 80]; ...
   'referenceRT',          nan; ...
   'trialsPerCoherence',   40; ....
   'saccadeDirections',    0:90:270; ... %0:45:315; ...
   'trialsPerDirection',   4; ...
   'uiDevice',             'dotsReadableEyePupilLabs'; ...
   'fixWindowSize',        3; ...
   'trgWindowSize',        4; ...
   'fixWindowDur',         0.02; ...
   'trgWindowDur',         0.02; ...
   'sendTTLs',             false; ...
   'useRemoteDrawing',     false; ...
   'displayIndex',         1; ...
   'filePath',             getTaskFilepath(); ...
   'fileName',             sprintf('data_%.4d_%02d_%02d_%02d_%02d.mat', c(1), c(2), c(3), c(4), c(5)); ...
   };

% Arguments are property/value pairs
for ii = 1:2:nargin-2
   defaultArguments{strcmp(varargin{ii}, defaultArguments(:,1)),2} = varargin{ii+1};
end

% Save to state list
for ii = 1:size(defaultArguments, 1)
   datatub{'Input'}{defaultArguments{ii,1}} = defaultArguments{ii,2};
end

%% ---- Configure common drawables
%
% Make the screen ensemble
screenEnsemble = makeScreenEnsemble( ...
   datatub{'Input'}{'useRemoteDrawing'}, datatub{'Input'}{'displayIndex'});
datatub{'Graphics'}{'screenEnsemble'} = screenEnsemble;

% Make a text ensemble for showing messages.
textEnsemble = makeTextEnsemble('text', 2, [], screenEnsemble);
datatub{'Graphics'}{'textEnsemble'} = screenEnsemble;

% Add screen start/finish fevalables to the main topsTreeNode
addCall(datatub{'Control'}{'startCallList'}, ...
   {@callObjectMethod, screenEnsemble, @open}, 'openScreen');
addCall(datatub{'Control'}{'finishCallList'}, ...
   {@callObjectMethod, screenEnsemble, @close}, 'closeScreen');
addCall(datatub{'Control'}{'finishCallList'}, ...
   {@showTaskText, textEnsemble, {'All done', 'Thank you!'}, 10}, 'finalMessage');

%% ---- Configure User input : pupil labs or keyboard
%
% Always use a keyboard for control commands entered between trials
kb = getTaskMatchingKeyboard();

% Define keypress events, undefine the rest
kb.deactivateEvents();

% Automatically read when checking for events
kb.isAutoRead = true;

% Try to use tne named input device as primary input
if strcmp(datatub{'Input'}{'uiDevice'}, 'dotsReadableEyePupilLabs') || ...
      strcmp(datatub{'Input'}{'uiDevice'}, 'dotsReadableEyeMouseSimulator')
   
   % Get the pupl labs eye tracking object
   ui = eval(datatub{'Input'}{'uiDevice'});
   
   % Make sure it's working
   if ~ui.isAvailable
      ui = dotsReadableEyeMouseSimulator();
   end
   
   % Automatically read during getNextEvent calls
   ui.isAutoRead = true;
   
   % Add the screenEnsemble for calibration drawing
   ui.screenEnsemble = screenEnsemble;
   
   % Set up the eye position monitor
   ui.openGazeMonitor();
   
   % Set the data file to the same name as the current file, with
   % _pupilLabs suffix
   [~, name, ~] = fileparts(datatub{'Input'}{'fileName'});
   ui.filename = sprintf('%s_pupilLabs', name);
   
   % Add start/finish fevalables to the main topsTreeNode
   %  START calibration, recording
   addCall(datatub{'Control'}{'startCallList'}, {@calibrate, ui}, 'calibrate eye');
   addCall(datatub{'Control'}{'startCallList'}, {@record, ui, true}, 'start recording eye');
   
   %  Finish calibration, recording
   addCall(datatub{'Control'}{'finishCallList'}, {@record, ui, false}, 'finish recording eye');
   addCall(datatub{'Control'}{'finishCallList'}, {@close, ui}, 'close eye');
   
else
   
   % Otherwise use the keyboard
   ui = kb;
end

% Save the devices
datatub{'Control'}{'keyboard'} = kb;
datatub{'Control'}{'userInputDevice'} = ui;

% Add a maintask finish fevalable to close the kb
addCall(datatub{'Control'}{'finishCallList'}, {@close, kb}, 'close keyboard');

%% ---- Configure Tasks + State Machines
%
% list of all possible task names, to get IDs
taskNames = {'VGS' 'MGS' 'Quest' 'NN' 'NL' 'NR' 'SN' 'SL' 'SR' ...
   'AN' 'AL' 'AR'};

SATstrings = { ...
   'S' 'Be as fast as possible'; ...
   'A' 'Be as accurate as possible'; ...
   'N' 'Be as fast and accurate as possible'};

BIASstrings = { ...
   'L' 'LEFT is more likely'; ...
   'R' 'RIGHT is more likely'; ...
   'N' 'BOTH directions equally likely'};

% Loop through the taskSpecs array, making and adding tasks
taskSpecs = datatub{'Input'}{'taskSpecs'};
taskNumber = 1; % for feedback (see RTDstartTrial)
for tt = 1:2:length(taskSpecs)
   
   % Parse the name and trial numbers from sequential arguments
   name = taskSpecs{tt};
   trialsPerCondition = taskSpecs{tt+1};
   
   % Add task-specific information, depending on the named type
   switch (name)
      
      case {'VGS', 'MGS'}
         
         % Saccade task!
         %
         task = topsTreeNodeTaskSaccade(name);

         % Set instruction strings
         if strcmp(name, 'VGS')
            task.instructionStrings = { 'When the fixation spot disappears', ...
               'Look at the visual target'};
      
         else
            task.instructionStrings = { 'When the fixation spot disappears', ...
               'Look at the remebered location of the visual target'};
         end
         
         % check to update saccade directions, trials per direction
         setIfNotEmpty(task.trialProperties.directions, datatub{'Input'}{'saccadeDirections'});
         setIfNotEmpty(task.trialProperties.trialsPerDirection, trialsPerCondition);

      otherwise
         
         % Dots task!
         %
         task = topsTreeNodeTaskDTDots(name);
         
         % Check for Quest
         if strcmp(name, 'Quest')
            
            % Send flag to use Quest for coherence
            task.trialProperties.coherences = 'Quest';

            % Set input coherence to nan, which signals all other tasks to
            % use the Quest coherence
            datatub{'Input'}{'coherences'} = nan;
            
            % Use Neutral specs
            name = 'NN';
         else
            
            % check to update coherences
            setIfNotEmpty(task.trialProperties.coherences, datatub{'Input'}{'coherences'});
         end
         
         % check to update dot directions, trials per coherence
         setIfNotEmpty(task.trialProperties.directions, datatub{'Input'}{'dotDirections'});
         setIfNotEmpty(task.trialProperties.trialsPerCoherence, trialsPerCondition);

         % Parse name for task specifications (see comments at the top)
         instructions{1} = SATstrings{strcmp(
         %
         % First character is speed/accuracy condition
         instructions = {'', ''};
         switch name(1)
            
            case 'N' % neutral
               instructions{1} = 'Be as fast and accurate as possible';
               
            case 'S' % speed
               instructions{1} = 'Be as fast as possible';
               
            case 'A' % accuracy
               instructions{1} = 'Be as accurate as possible';
         end
         
         % Second character is bias condition
         priors = datatub{'Input'}{'biasedPriors'};
         switch name(2)
            
            case 'N' % neutral
               instructions{2} = 'BOTH directions equally likely';
               
            case 'L'
               instructions{2} = 'LEFT is more likely';
               task.trialProperties.directionPriors = [max(priors) min(priors)];
               
            case 'R'
               instructions{2} = 'RIGHT is more likely';
               task.trialProperties.directionPriors = [min(priors) max(priors)];
         end
         
         % Set the instructions
         task.instructionStrings = instructions;
   end
   
   % check to update gaze window properties
   setIfNotEmpty(task.fixWindowSize, datatub{'Input'}{'fixWindowSize'});
   setIfNotEmpty(task.fixWindowDur,  datatub{'Input'}{'fixWindowDur'});
   setIfNotEmpty(task.trgWindowSize, datatub{'Input'}{'trgWindowSize'});
   setIfNotEmpty(task.trgWindowDur,  datatub{'Input'}{'trgWindowDur'});
   
   % call the configure command
   task.configure();
   
   % Set remaining task properties
   % We use the taskID property of the task to keep track of the task
   % number (i.e., just the incremental order of the tasks used), but the
   % taskID property of the trial as the unique task-type identifier,
   % which we'll need to parse/analyze the data
   task.iterations       = inf;
   task.trialData.taskID = find(strcmp(name, taskNames));
   task.taskID           = taskNumber;
   taskNumber            = taskNumber + 1;
   
   % add the task
   maintask.addChild(task);
end

% Set up references that may or may not be overriden by Quest/MeanRT tasks
datatub{'Task'}{'referenceRT'} = datatub{'Input'}{'referenceRT'};
datatub{'Task'}{'referenceCoherence'} = datatub{'Input'}{'coherences'};


   
   